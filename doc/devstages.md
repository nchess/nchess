# Development phases #

## Define gameplay ##

What does the the table look like? Is it made of regular ngons? Is it a graph? Is it a graph but with limitations?

How does each piece move? How do you define diagonal in graphs or on ngons?

Are the win/lose states affected?

## Get some kind of map up and running ##

This means getting some data structure for storing maps in a convenient way.

After that's done, make up some file format to store them. Pre-existing and/or easy solutions are preferred. For example JSON, **maybe** XML, or heck, even CSV. No need for human readable formats, since these will be generated by applications, not written by hand. Text-based formats also preferred, because ease of storage, transmission and error-checking.

Pieces also need to be stored on these. Just a reminder.

## Get visual! ##

This would be the first client. At first, this client only needs to have some kind of a map in memory. Could be even hard-coded ( and possibly should be ). Then, get it on-screen!

Options considered are Java and C++.

**Java** would be nice because it would yield more things to be learned. Play a bit more with maven, learn how visual things are created with Java ( AWT? ), and do some more user interfaces.

However, I really don't feel like digging into Java's graphical guts. Sure, JavaFX is nice, things are productive, and heck. I still have a bad feeling about it. Maybe a Java client at a later stage?

Or, I could use some kind of realtime graphics library ( a nice, high-level wrapper on OpenGL possibly ), and include a __really__ simple UI. Sounds bad. More work, more hassle, possibly has been already done for me.

**C++** is really nice and comfortable. What UI library to use tho? Qt? GTK? FLTK? wxWidgets? I have no experience with any of them.

Whichever route, the UI library of choice should support some kind of interactive graphics, or some way to do it externally. Imagine a frame in a window which is owned by another library which wraps OpenGL, for example.

( Yes, I like mentioning OpenGL. I like OpenGL. )

## Start networking ##

At this point, a really simple **server** could be started.

 * It would be a simple console application.
 * At launch, it is given a map. Loads the map, then waits for clients.
 * When a client connects, it just sends over the map. Once it's acknowledged, the connection is closed.

Networking also presumes some kind of a protocol. A protocol should be defined, which is:

 * Text based
 * Human-readable
 * Acknowledges? This should be handled by TCP. Think about it.
 * For longer operations, provide some sort of progress. People LOVE progress-bars.
 * I like lists, too.

The client should also be updated for this occasion. The client receives the whole map data from the server after connecting.

## Human vs. human ##

The next step is actual gameplay. The client needs to be able to handle piece selections and moves. Also, the client should be able to display the possible move for selected pieces.

**This is actually an interesting question.** Since the server has the rules anyways, why not just ask the server about a piece's moves? Having the move validation code in all the clients AND the server(s?) is plain redundancy. Also, if the server's code is updated but the client's is not, that would cause issues. Heck, what if multiple rulesets are created? I'm really leaning towards the ask-the-server architecture.

For this, the server also needs upgrades. The server has to validate each player's moves and ensure rules.
The clients send action **requests**, which the server either accepts or denies.
The server also needs to broadcast game state. This is done two ways: send the latest move, or send the whole game state. Sending the last move sounds secure enough, but as an additional measure, the whole game state will be sent every once in a while. ( Could this be something configurable? )
The clients should also be able to query the server about the game. Who's turn is it, for example.

If a client doesn't respond, it will be dropped after a timeout is hit.

### Make this a proper server ###

Since it's well past 1995, we can host more than one game session on a single server. Obviously, one could run the server on multiple ports and done.

However! We can still do better than that.

 * Once joined, the clients would enter a lobby. From the lobby, the clients can list currently running game rooms.
 * Clients can also join these rooms ( if there's at least one free slot ), or create them.
 * Upon room creation, the client could choose from the maps on the server. It would be simply a list of names. ( At least at first )
 * Once a game is done, players can leave or start another game.
 * A room is closed once everyone quits.

## Human vs. AI ##

This is where the actual point of the project kicks in - AI. Each AI opponent is an actual client in itself, which can be launched from the command line with the right arguments ( server IP, port ). The AI would then communicate with the server about the game state and send its moves.

If multiple clients are planned, a common code-base could be useful. For example, a framework which handles the networking and game state management, and asks the user code once in a while about the next move. This would make it easy to quickly write up multiple algorithms and test how they perform. Even against other AI's.

__(And at this point I'll have to open a Special Thanks To document and include Annamari and Dia)__

### Emotive AI ###

That's a clickbait title.

To begin with, these AI opponents should be configurable. At the very least, let the user set the difficulty. Maybe add some other attributes, if feasible. The point is, have a standard parameter set which is obeyed by every AI opponent, so a unified way is given to configure the opponents.

Also, depending on the planned algorithms, some optional, yet general parameters could be established.

For example:

  * Aggression - prefer short term advantages over long term.
  * Protectiveness - prefer not losing pieces
  * I will have to think **really hard** about these.

AI opponents will also necessarily differ the way they work and think. This also provides some additional parameters, based on their algorithms.

## ??? ##

## PROFIT ##

All is well,

All is great,

Imma graduate,

yay
